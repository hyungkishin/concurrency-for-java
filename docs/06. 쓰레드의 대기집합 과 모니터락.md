Java에서 객체가 모니터 락과 스레드 대기 집합을 가지고 있다는 것은 언어의 스펙과 JVM의 구현에 따른 것이다. <br/>
이러한 동작은 JVM 내부에서 관리되며, 일반적인 디버깅 도구로 직접 관찰하기는 어렵다. <br/>
그러나 아래와 같은 방법을 통해 이러한 메커니즘이 실제로 작동하고 있음을 간접적으로 확인할 수 있다 <br/>

1. 동기화 코드 작성 및 테스트:
- synchronized 키워드를 사용하여 메서드나 블록을 동기화하고, 여러 스레드가 동시에 접근할 때 동기화가 제대로 이루어지는지 테스트할 수 있다.
- 예를 들어, 여러 스레드가 동시에 synchronized 메서드를 호출할 때, 스레드가 차례로 실행되는 것을 확인할 수 있다.
2. 스레드 상태 확인:
- Java의 Thread 클래스에는 getState() 메서드가 있어 스레드의 현재 상태를 확인할 수 있습니다. 스레드가 BLOCKED 상태에 있다면, 다른 스레드가 모니터 락을 보유하고 있어 대기 중이라는 것을 알 수 있다.
3. JVM 옵션 및 도구 사용:
- JVM의 특정 옵션을 사용하여 락 관련 정보를 출력할 수 있습니다. 
  - "-Djava.util.concurrent.ForkJoinPool.commonPool.parallelism" 옵션을 사용하거나, jstack 명령을 통해 스레드 덤프를 분석하여 스레드가 어디서 대기하고 있는지 확인할 수 있.
- jconsole, VisualVM 같은 도구를 사용하면 스레드의 상태와 락 정보를 시각적으로 확인할 수 있다.
4. 로그 및 출력:
- 동기화 블록의 진입과 종료 시점에 로그를 찍어 스레드가 언제 락을 획득하고 해제하는지 추적할 수 있다.
  - 이를 통해 동기화가 예상대로 작동하는지 확인할 수 있다.
- 이러한 방법들을 통해 Java의 동기화 메커니즘이 제대로 작동하고 있음을 확인할 수 있습니다.
- 객체의 모니터 락과 대기 집합은 JVM이 관리하는 내부적인 구조이므로, 직접적으로 보거나 수정할 수는 없다.
5. lock 이랑 스레드 대기집합은 같은 인스턴스것을 사용한다.

### 생산, 소비자 문재 - Object 효율 측면
- 스레드 기아 ( thread starvation ) 문제가 발생할 수 있다 
  - notify() 의 문제는 어떤 스레드가 깨어날 지 알 수 없기 때문에 발생할 수 있는 기아 문제가 있다.
- 스레드 대기 집합에서 어떤 종류의 스레드가 깨어날지 알 수 없다.

### 정리 (synchronized 자바 언어가 만들어질때부터.)
- 자바의 모든 객체 인스턴스는 멀티스레드와 임계 영역을 다루기 위해 내부에 3가지 기본요소를 가진다.
  - 모니터 락
  - 락 대기 집합(모니터 락 대기집합)
  - 스레드 대기 집합

### 3가지 요소 (모니터 락, 락 대기 집합(모니터 락 대기집합), 스레드 대기 집합)
- 서로 맞물려 돌아간다.
- synchronized 를 사용한 임계 영역에 들어가려면 모니터 락이 필요하다.
- 모니터 락이 없으면 락 대기집합에 들어가서 BLOKED 상태로 락을 기다린다.
- 모니터 락을 반납하면 락 대기 집합에 있는 스레드 중 하나가 락을 획득하고 BLOCKED -> RUNNABLE 상태가 된다.
