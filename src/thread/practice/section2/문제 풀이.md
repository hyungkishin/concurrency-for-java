### 메모리 가시성 해결을 위한 volatile 키워드로 충분할것 같지만 왜 결과는 그렇지 않을까 ?
> volatile 키워드는 변수의 값을 여러 스레드 간에 즉시 일관되게 보이게 하는 데 사용된다. <br/>
> 하지만 volatile 키워드는 원자성을 보장하지 않는 문제가 있다. <br/> 
> 즉, volatile 변수를 사용하는 읽기 및 쓰기 작업은 원자적이지만, 복합 작업(예: 읽고, 수정하고, 다시 쓰기)은 원자적이지 않는다는 점이다.
> increment 메서드에서 count 변수를 증가시키는 작업은 다음과 같은 세 단계로 이루어 진다 <br/>
> 1.	count의 현재 값을 읽는다.
> 2.	그 값을 1 증가시킨다.
> 3.	증가된 값을 count 에 대입한다.

- 이 세 단계는 원자적으로 수행되지 않기 때문에, 여러 스레드가 동시에 increment 메서드를 호출하면 경쟁 조건이 발생할 수 있습니다. 예를 들어, 두 스레드가 동시에 count 값을 읽고 동일한 값을 기반으로 증가시키면, count 값이 실제로는 한 번만 증가하는 문제가 발생할 수 있다. <br/>
- volatile 키워드는 변수의 최신 값을 보장하지만, 증가 연산이 원자적으로 이루어지도록 보장하지 않는다. <br/>
- 따라서 volatile 키워드를 사용해도 increment 메서드의 복합 작업이 안전하게 수행되지 않는다. <br/>
